# Azure DevOps Pipeline for FYPhish
# Multi-stage pipeline with Infrastructure as Code and application deployment
# Supports multiple environments and easy account migration

trigger:
  branches:
    include:
    - main
    - develop
    - release/*
  paths:
    exclude:
    - README.md
    - docs/*
    - .gitignore

pr:
  branches:
    include:
    - main
    - develop
  paths:
    exclude:
    - README.md
    - docs/*
    - .gitignore

# Pipeline variables
variables:
  # Build Configuration
  buildConfiguration: 'Release'
  goVersion: '1.23'
  dockerRegistryServiceConnection: 'ACR-Connection'

  # Environment-specific variables
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
    environmentName: 'prod'
    deploymentApproval: true
  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
    environmentName: 'test'
    deploymentApproval: false
  ${{ else }}:
    environmentName: 'dev'
    deploymentApproval: false

# Resource references
resources:
  repositories:
  - repository: self
    type: git
    name: FYPhish

stages:
# Stage 1: Build and Test
- stage: BuildAndTest
  displayName: 'Build and Test'
  jobs:
  - job: BuildApplication
    displayName: 'Build Go Application'
    pool:
      vmImage: 'ubuntu-latest'

    steps:
    # Checkout code
    - checkout: self
      fetchDepth: 0

    # Setup Go environment
    - task: GoTool@0
      displayName: 'Set up Go $(goVersion)'
      inputs:
        version: '$(goVersion)'

    # Setup Node.js for frontend build
    - task: NodeTool@0
      displayName: 'Set up Node.js'
      inputs:
        versionSpec: '18.x'

    # Cache Go modules
    - task: Cache@2
      displayName: 'Cache Go modules'
      inputs:
        key: 'go | "$(Agent.OS)" | go.sum'
        restoreKeys: |
          go | "$(Agent.OS)"
        path: '$(GOPATH)/pkg/mod'

    # Install Go dependencies
    - script: |
        go mod download
        go mod verify
      displayName: 'Download Go dependencies'

    # Install Node.js dependencies
    - script: |
        npm ci
        npm install -g gulp-cli
      displayName: 'Install Node.js dependencies'

    # Build frontend assets
    - script: |
        gulp
      displayName: 'Build frontend assets'

    # Run Go tests
    - script: |
        go test -v -race -coverprofile=coverage.out ./...
      displayName: 'Run Go tests'
      continueOnError: false

    # Publish test results
    - task: PublishTestResults@2
      displayName: 'Publish test results'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/test-results.xml'
        failTaskOnFailedTests: true
      condition: always()

    # Publish code coverage
    - task: PublishCodeCoverageResults@1
      displayName: 'Publish code coverage'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '**/coverage.out'
      condition: always()

    # Security scan with Nancy (for Go dependencies)
    - script: |
        go install github.com/sonatypecommunity/nancy@latest
        go list -json -deps ./... | nancy sleuth
      displayName: 'Security scan with Nancy'
      continueOnError: true

    # Build Go binary
    - script: |
        CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -installsuffix cgo -o fyphish .
      displayName: 'Build Go binary'

    # Publish build artifacts
    - task: PublishBuildArtifacts@1
      displayName: 'Publish build artifacts'
      inputs:
        PathtoPublish: '.'
        ArtifactName: 'fyphish-app'
        publishLocation: 'Container'

# Stage 2: Build and Push Docker Image
- stage: BuildContainer
  displayName: 'Build Container Image'
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
  - job: BuildDockerImage
    displayName: 'Build and Push Docker Image'
    pool:
      vmImage: 'ubuntu-latest'

    steps:
    # Download build artifacts
    - task: DownloadBuildArtifacts@0
      displayName: 'Download build artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'fyphish-app'
        downloadPath: '$(System.ArtifactsDirectory)'

    # Copy artifacts to working directory
    - script: |
        cp -r $(System.ArtifactsDirectory)/fyphish-app/* $(Build.SourcesDirectory)/
      displayName: 'Copy artifacts'

    # Build and push Docker image
    - task: Docker@2
      displayName: 'Build and push Docker image'
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: 'fyphish'
        command: 'buildAndPush'
        Dockerfile: 'infrastructure/docker/Dockerfile.optimized'
        tags: |
          $(Build.BuildId)
          latest
          $(environmentName)-latest

    # Run container security scan
    - task: AquaSecurityTrivy@0
      displayName: 'Container security scan'
      inputs:
        image: '$(containerRegistry)/fyphish:$(Build.BuildId)'
        exitCode: '1'
      continueOnError: true

# Stage 3: Deploy Infrastructure
- stage: DeployInfrastructure
  displayName: 'Deploy Infrastructure - $(environmentName)'
  dependsOn: BuildContainer
  condition: succeeded()
  jobs:
  - deployment: DeployInfra
    displayName: 'Deploy Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'fyphish-$(environmentName)'
    strategy:
      runOnce:
        deploy:
          steps:
          # Download infrastructure templates
          - checkout: self

          # Azure CLI login
          - task: AzureCLI@2
            displayName: 'Deploy infrastructure with Bicep'
            inputs:
              azureSubscription: 'Azure-ServiceConnection-$(environmentName)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Set variables based on environment
                UNIQUE_SUFFIX=$(echo $RANDOM | md5sum | head -c 6)

                # Deploy infrastructure
                az deployment sub create \
                  --location "East US" \
                  --template-file infrastructure/bicep/main.bicep \
                  --parameters \
                    environment=$(environmentName) \
                    uniqueSuffix=$UNIQUE_SUFFIX \
                    adminEmail=$(adminEmail) \
                    allowedDomain=$(allowedDomain) \
                    enableReadReplica=${{ eq(variables.environmentName, 'prod') }} \
                    enableAppGateway=${{ eq(variables.environmentName, 'prod') }} \
                  --name "fyphish-$(environmentName)-$(Build.BuildId)"

                # Store outputs for next stage
                DEPLOYMENT_OUTPUTS=$(az deployment sub show \
                  --name "fyphish-$(environmentName)-$(Build.BuildId)" \
                  --query 'properties.outputs' \
                  --output json)

                echo "##vso[task.setvariable variable=resourceGroupName;isOutput=true]$(echo $DEPLOYMENT_OUTPUTS | jq -r '.resourceGroupName.value')"
                echo "##vso[task.setvariable variable=acrName;isOutput=true]$(echo $DEPLOYMENT_OUTPUTS | jq -r '.acrName.value')"
                echo "##vso[task.setvariable variable=keyVaultName;isOutput=true]$(echo $DEPLOYMENT_OUTPUTS | jq -r '.keyVaultName.value')"
              name: 'deployInfra'

# Stage 4: Configure Secrets
- stage: ConfigureSecrets
  displayName: 'Configure Secrets - $(environmentName)'
  dependsOn: DeployInfrastructure
  condition: succeeded()
  variables:
    resourceGroupName: $[ stageDependencies.DeployInfrastructure.DeployInfra.outputs['deployInfra.resourceGroupName'] ]
    keyVaultName: $[ stageDependencies.DeployInfrastructure.DeployInfra.outputs['deployInfra.keyVaultName'] ]
  jobs:
  - job: ConfigureSecrets
    displayName: 'Configure Key Vault Secrets'
    pool:
      vmImage: 'ubuntu-latest'

    steps:
    # Configure OAuth and session secrets
    - task: AzureCLI@2
      displayName: 'Configure Key Vault secrets'
      inputs:
        azureSubscription: 'Azure-ServiceConnection-$(environmentName)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Generate session keys if they don't exist
          SIGNING_KEY=$(openssl rand -hex 64)
          ENCRYPTION_KEY=$(openssl rand -hex 32)

          # Set secrets in Key Vault
          az keyvault secret set \
            --vault-name $(keyVaultName) \
            --name "microsoft-client-id" \
            --value "$(microsoftClientId)"

          az keyvault secret set \
            --vault-name $(keyVaultName) \
            --name "microsoft-client-secret" \
            --value "$(microsoftClientSecret)"

          az keyvault secret set \
            --vault-name $(keyVaultName) \
            --name "microsoft-tenant-id" \
            --value "$(microsoftTenantId)"

          az keyvault secret set \
            --vault-name $(keyVaultName) \
            --name "session-signing-key" \
            --value "$SIGNING_KEY"

          az keyvault secret set \
            --vault-name $(keyVaultName) \
            --name "session-encryption-key" \
            --value "$ENCRYPTION_KEY"

          # Set MySQL admin password
          MYSQL_PASSWORD=$(openssl rand -base64 32)
          az keyvault secret set \
            --vault-name $(keyVaultName) \
            --name "mysql-admin-password" \
            --value "$MYSQL_PASSWORD"

# Stage 5: Deploy Application
- stage: DeployApplication
  displayName: 'Deploy Application - $(environmentName)'
  dependsOn:
  - DeployInfrastructure
  - ConfigureSecrets
  condition: succeeded()
  variables:
    resourceGroupName: $[ stageDependencies.DeployInfrastructure.DeployInfra.outputs['deployInfra.resourceGroupName'] ]
    acrName: $[ stageDependencies.DeployInfrastructure.DeployInfra.outputs['deployInfra.acrName'] ]
  jobs:
  - deployment: DeployApp
    displayName: 'Deploy Application'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'fyphish-$(environmentName)'
    strategy:
      runOnce:
        deploy:
          steps:
          # Update container instances with new image
          - task: AzureCLI@2
            displayName: 'Deploy application container'
            inputs:
              azureSubscription: 'Azure-ServiceConnection-$(environmentName)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Get ACR login server
                ACR_LOGIN_SERVER=$(az acr show --name $(acrName) --resource-group $(resourceGroupName) --query 'loginServer' --output tsv)

                # Update container group with new image
                az container restart \
                  --resource-group $(resourceGroupName) \
                  --name "aci-fyphish-$(environmentName)-*"

                # Wait for deployment to complete
                echo "Waiting for application to start..."
                sleep 30

                # Health check
                for i in {1..10}; do
                  if az container show \
                    --resource-group $(resourceGroupName) \
                    --name "aci-fyphish-$(environmentName)-*" \
                    --query 'containers[0].instanceView.currentState.state' \
                    --output tsv | grep -q "Running"; then
                    echo "Application is running successfully"
                    break
                  fi
                  echo "Waiting for application... (attempt $i/10)"
                  sleep 30
                done

# Stage 6: Run Integration Tests
- stage: IntegrationTests
  displayName: 'Integration Tests - $(environmentName)'
  dependsOn: DeployApplication
  condition: succeeded()
  variables:
    resourceGroupName: $[ stageDependencies.DeployInfrastructure.DeployInfra.outputs['deployInfra.resourceGroupName'] ]
  jobs:
  - job: RunIntegrationTests
    displayName: 'Run Integration Tests'
    pool:
      vmImage: 'ubuntu-latest'

    steps:
    # Get application URL
    - task: AzureCLI@2
      displayName: 'Get application URL'
      inputs:
        azureSubscription: 'Azure-ServiceConnection-$(environmentName)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          APP_URL=$(az container show \
            --resource-group $(resourceGroupName) \
            --name "aci-fyphish-$(environmentName)-*" \
            --query 'ipAddress.fqdn' \
            --output tsv)

          echo "##vso[task.setvariable variable=applicationUrl]http://$APP_URL:3333"
      name: 'getAppUrl'

    # Run health checks
    - script: |
        echo "Testing application health at $(applicationUrl)"

        # Wait for application to be ready
        for i in {1..10}; do
          if curl -f "$(applicationUrl)/health" > /dev/null 2>&1; then
            echo "Health check passed"
            break
          fi
          echo "Waiting for health check... (attempt $i/10)"
          sleep 10
        done

        # Test key endpoints
        curl -f "$(applicationUrl)/health" || exit 1
        curl -f "$(applicationUrl)/ready" || exit 1
        curl -s "$(applicationUrl)" | grep -q "FYPhish" || exit 1

        echo "All integration tests passed"
      displayName: 'Run health checks and integration tests'

# Stage 7: Production Approval (only for prod)
- stage: ProductionApproval
  displayName: 'Production Approval'
  dependsOn: IntegrationTests
  condition: and(succeeded(), eq(variables.environmentName, 'prod'))
  jobs:
  - job: WaitForApproval
    displayName: 'Wait for Manual Approval'
    pool: server
    timeoutInMinutes: 1440 # 24 hours
    steps:
    - task: ManualValidation@0
      displayName: 'Manual approval for production deployment'
      inputs:
        instructions: 'Please validate the application deployment and approve for production'
        onTimeout: 'reject'

# Stage 8: Cleanup (for non-prod environments)
- stage: Cleanup
  displayName: 'Cleanup - $(environmentName)'
  dependsOn: IntegrationTests
  condition: and(succeeded(), ne(variables.environmentName, 'prod'))
  variables:
    resourceGroupName: $[ stageDependencies.DeployInfrastructure.DeployInfra.outputs['deployInfra.resourceGroupName'] ]
  jobs:
  - job: ScheduleCleanup
    displayName: 'Schedule Resource Cleanup'
    pool:
      vmImage: 'ubuntu-latest'

    steps:
    # Tag resources for cleanup (automation can clean up later)
    - task: AzureCLI@2
      displayName: 'Tag resources for automated cleanup'
      inputs:
        azureSubscription: 'Azure-ServiceConnection-$(environmentName)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Calculate cleanup date (7 days for dev, 14 days for test)
          if [ "$(environmentName)" = "dev" ]; then
            CLEANUP_DAYS=7
          else
            CLEANUP_DAYS=14
          fi

          CLEANUP_DATE=$(date -d "+$CLEANUP_DAYS days" +%Y-%m-%d)

          # Tag resource group for cleanup
          az group update \
            --name $(resourceGroupName) \
            --set tags.AutoCleanup=$CLEANUP_DATE \
            --set tags.Environment=$(environmentName) \
            --set tags.BuildId=$(Build.BuildId)